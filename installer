#!/bin/sh
########################################################################################################
#           _____ _    _  _______          _______ _______     __  __ ______ _____  _      _____ _   _ #
#    /\    / ____| |  | |/ ____\ \        / |  __ |__   __|   |  \/  |  ____|  __ \| |    |_   _| \ | |#
#   /  \  | (___ | |  | | (___  \ \  /\  / /| |__) | | |______| \  / | |__  | |__) | |      | | |  \| |#
#  / /\ \  \___ \| |  | |\___ \  \ \/  \/ / |  _  /  | |______| |\/| |  __| |  _  /| |      | | | . ` |#
# / ____ \ ____) | |__| |____) |  \  /\  /  | | \ \  | |      | |  | | |____| | \ \| |____ _| |_| |\  |#
#/_/    \_|_____/ \____/|_____/    \/  \/   |_|  \_\ |_|      |_|  |_|______|_|  \_|______|_____|_| \_|#
#                                                                                                      #
# _____  _   _  _____  _____ _______     _______ _______     _____  _____   ______   ___     __        #
#|  __ \| \ | |/ ____|/ ____|  __ \ \   / |  __ |__   __|   |  __ \|  __ \ / __ \ \ / \ \   / /        #
#| |  | |  \| | (___ | |    | |__) \ \_/ /| |__) | | |______| |__) | |__) | |  | \ V / \ \_/ /         #
#| |  | | . ` |\___ \| |    |  _  / \   / |  ___/  | |______|  ___/|  _  /| |  | |> <   \   /          #
#| |__| | |\  |____) | |____| | \ \  | |  | |      | |      | |    | | \ \| |__| / . \   | |           #
#|_____/|_| \_|_____/ \_____|_|  \_\ |_|  |_|      |_|      |_|    |_|  \_\\____/_/ \_\  |_|           #
#                                                                                                      #
# _____ _   _  _____ _______       _      _      ______ _____     Original Author:                     #
#|_   _| \ | |/ ____|__   __|/\   | |    | |    |  ____|  __ \             bigeyes0x0                  #
#  | | |  \| | (___    | |  /  \  | |    | |    | |__  | |__) |   Current Maintainer:                  #
#  | | | . ` |\___ \   | | / /\ \ | |    | |    |  __| |  _  /             SomeWhereOverTheRainBow     #
# _| |_| |\  |____) |  | |/ ____ \| |____| |____| |____| | \ \                                         #
#|_____|_| \_|_____/   |_/_/    \_|______|______|______|_|  \_\   v2.1.7                               #
#                                                                                                      #
########################################################################################################
export DI_VERSION="v2.1.7"
LATEST_URL="https://api.github.com/repos/jedisct1/dnscrypt-proxy/releases/latest"
DNSCRYPT_VER="$(curl -sL "$LATEST_URL" | grep "tag_name" | head -1 | cut -d \" -f 4)"

BOLD="\033[1m"
NORM="\033[0m"
INFO="$BOLD Info: $NORM"
ERROR="$BOLD *** Error: $NORM"
WARNING="$BOLD * Warning: $NORM"
INPUT="$BOLD => $NORM"

readonly BASE_DIR=/jffs
readonly TARG_DIR=$BASE_DIR/dnscrypt
readonly CONF_FILE=$TARG_DIR/.config
readonly TOML_FILE=$TARG_DIR/dnscrypt-proxy.toml
readonly TOML_BAK=$TARG_DIR/dnscrypt-proxy.toml.bak
readonly TOML_ERR=$TARG_DIR/dnscrypt-proxy.toml.err
readonly TOML_ORI=$TARG_DIR/example-dnscrypt-proxy.toml

_quote() {
  echo "$1" | sed 's/[]\/()$*.^|[]/\\&/g'
}

ScriptHeader () {
        clear
        sed -n '2,24p' "$0"
	if [ "$1" = "STARTUP" ]; then
		check_jffs_enabled
		check_dns_environment
		cleanup
		check_version
		menu
        else
	        check_version
		menu
	fi
}

backup_restore () {
  if [ "$1" = "BACKUP" ] && [ -d $TARG_DIR ] && [ -f ${TARG_DIR}/dnscrypt-proxy ]; then
    printf "%s\n" "$INFO This operation will backup dnscrypt-proxy(<4MB)to jffs partition." "$INFO Please wait a moment."
    if [ -f $BASE_DIR/backup_dnscrypt.tar.gz ]; then
      printf "%s\n" "$INFO There is an old backup detected."
      local USE_OLD
      read_yesno "Do you want to continue?(this will remove the old backup)" && USE_OLD=NO || USE_OLD=YES
      if [ "$USE_OLD" = "YES" ]; then
        printf "%s\n" "$INFO Leaving Old Backup."
	end_op_message
      elif [ "$USE_OLD" = "NO" ]; then
	printf "%s\n" "$INFO Removing Old Backup."
	rm -rf $BASE_DIR/backup_dnscrypt.tar.gz
      fi
    fi
    tar -czvf $BASE_DIR/backup_dnscrypt.tar.gz -C $TARG_DIR ../dnscrypt/ >/dev/null 2>&1    
    printf "%s\n" "$INFO Backup complete"
    end_op_message 0
  elif [ "$1" = "BACKUP" ] && [ ! -d $TARG_DIR ] && [ ! -f ${TARG_DIR}/dnscrypt-proxy ]; then
    printf "%s\n" "$ERROR $TARG_DIR/dnscrypt-proxy to Backup!"
    end_op_message
  fi
  if [ -f $BASE_DIR/backup_dnscrypt.tar.gz ] && [ "$1" = "RESTORE" ]; then
    printf "%s\n" "$INFO Please wait a moment."
    tar -xzvf $BASE_DIR/backup_dnscrypt.tar.gz -C $BASE_DIR >/dev/null 2>&1
    chown "$(nvram get http_username)":root $TARG_DIR/*
    chmod 755 $TARG_DIR/dnscrypt-proxy
    local NW_STATE
    local RES_STATE
    ping 1.1.1.1 -c1 -W2 >/dev/null 2>&1
    NW_STATE=$?
    nslookup google.com >/dev/null 2>&1
    RES_STATE=$?
    if [ $NW_STATE -eq 0 ] && [ $RES_STATE -ne 0 ]; then
      printf "%s\n" "$ERROR No internet- Skipping the updating for Local Files."
    else
      local RURL
      RURL="https://raw.githubusercontent.com/thuantran/dnscrypt-asuswrt-installer/master/installer"
      local RESOLVERS_URL_PREFIX="https://download.dnscrypt.info/resolvers-list/v3/"
      printf "%s\n" "$INFO Please hold on while the latest local files are updated.."
      download_file $TARG_DIR 755 $RURL
      download_file $TARG_DIR 755 "$URL_GEN"/manager
      if [ "$("${TARG_DIR}/dnscrypt-proxy" -version)" = "2.0.44" ]; then
      	download_file $TARG_DIR 644 https://raw.githubusercontent.com/DNSCrypt/dnscrypt-proxy/19c0c3f7db918ada8dd1e7b9b857099c1bb8609b/dnscrypt-proxy/example-dnscrypt-proxy.toml
      fi
      download_file $TARG_DIR 644 $RESOLVERS_URL_PREFIX/public-resolvers.md \
        $RESOLVERS_URL_PREFIX/public-resolvers.md.minisig \
        $RESOLVERS_URL_PREFIX/relays.md \
        $RESOLVERS_URL_PREFIX/relays.md.minisig
    fi 
    chown nobody:nobody $TARG_DIR/public-resolvers.md $TARG_DIR/public-resolvers.md.minisig $TARG_DIR/relays.md $TARG_DIR/relays.md.minisig
    del_jffs_script /jffs/scripts/wan-start dnscrypt-start
    del_jffs_script /jffs/scripts/openvpn-event
    del_jffs_script /jffs/scripts/firewall-start
    del_jffs_script /jffs/scripts/wan-start
    write_manager_script /jffs/scripts/dnsmasq.postconf dnsmasq
    write_manager_script /jffs/scripts/init-start init-start
    setup_dnscrypt
    if [ $? -ne 0 ]; then
      end_op_message
      return
    fi

    printf "%s\n" "$INFO Starting dnscrypt-proxy..."
    $TARG_DIR/manager dnscrypt-start
    sleep 1
    if [ -z "$(pidof dnscrypt-proxy)" ]; then
      printf "%s\n" "$ERROR Couldn't start dnscrypt-proxy" "$ERROR Please send WebUI System Log to dev"
      end_op_message
      return
    fi
    service restart_dnsmasq >/dev/null 2>&1
    manager_monitor_restart
    printf "%s\n" "$INFO Backup restored!"    
    end_op_message 0
  elif [ ! -f $BASE_DIR/backup_dnscrypt.tar.gz ] && [ "$1" = "RESTORE" ]; then
    printf "%s\n" "$ERROR No Backup found!" "$ERROR Please make sure Backup Resides in $BASE_DIR"
    end_op_message
    return
  elif [ -f $BASE_DIR/backup_dnscrypt.tar.gz ] && [ "$1" = "INSTALL" ]; then
    local RURL
    RURL="https://raw.githubusercontent.com/thuantran/dnscrypt-asuswrt-installer/master/installer"
    local RESOLVERS_URL_PREFIX="https://download.dnscrypt.info/resolvers-list/v3/"
    printf "%s\n" "$INFO Please wait a moment."
    tar -xzvf $BASE_DIR/backup_dnscrypt.tar.gz -C $BASE_DIR >/dev/null 2>&1
    chown "$(nvram get http_username)":root $TARG_DIR/*
    chmod 755 $TARG_DIR/dnscrypt-proxy
    download_file $TARG_DIR 755 $RURL
    download_file $TARG_DIR 755 "$URL_GEN"/manager
    if [ "$("${TARG_DIR}/dnscrypt-proxy" -version)" = "2.0.44" ]; then
      download_file $TARG_DIR 644 https://raw.githubusercontent.com/DNSCrypt/dnscrypt-proxy/19c0c3f7db918ada8dd1e7b9b857099c1bb8609b/dnscrypt-proxy/example-dnscrypt-proxy.toml
    fi
    download_file $TARG_DIR 644 $RESOLVERS_URL_PREFIX/public-resolvers.md \
      $RESOLVERS_URL_PREFIX/public-resolvers.md.minisig \
      $RESOLVERS_URL_PREFIX/relays.md \
      $RESOLVERS_URL_PREFIX/relays.md.minisig
    chown nobody:nobody $TARG_DIR/public-resolvers.md $TARG_DIR/public-resolvers.md.minisig $TARG_DIR/relays.md $TARG_DIR/relays.md.minisig
    del_jffs_script /jffs/scripts/wan-start dnscrypt-start
    del_jffs_script /jffs/scripts/openvpn-event
    del_jffs_script /jffs/scripts/firewall-start
    del_jffs_script /jffs/scripts/wan-start
    write_manager_script /jffs/scripts/dnsmasq.postconf dnsmasq
    write_manager_script /jffs/scripts/init-start init-start
    setup_dnscrypt
    if [ $? -ne 0 ]; then
      end_op_message
      return
    fi
    printf "%s\n" "$INFO Starting dnscrypt-proxy..."
    $TARG_DIR/manager dnscrypt-start
    sleep 1
    if [ -z "$(pidof dnscrypt-proxy)" ]; then
      printf "%s\n" "$ERROR Couldn't start dnscrypt-proxy" "$ERROR Please send WebUI System Log to dev"
      end_op_message
      return
    fi
    service restart_dnsmasq >/dev/null 2>&1
    manager_monitor_restart

    printf "%s\n" "$INFO Backup restored!" "$INFO  - Add swap" "$INFO  - Add a RNG" "$INFO  - Set your timezone"
    end_op_message 0	
  fi
}

check_dnscrypt_toml () {
  [ ! -f $TOML_FILE ] && return
  printf "%s\n" "$INFO Checking dnscrypt-proxy configuration..."
  $TARG_DIR/dnscrypt-proxy -check -config $TOML_FILE
  if [ $? -ne 0 ]; then
    printf "%s\n" "$INFO Move invalid configuration file to $TOML_ERR" "$INFO Operation will continue with clean config file."
    mv $TOML_FILE $TOML_ERR
    return 1
  fi
}

check_dns_environment () {
  local DNSPRIV=$(nvram get dnspriv_enable)
  if [ "$DNSPRIV" -ne 0 ]; then
    printf "%s\n" "$INFO Setting up Correct DNS Environment."
    nvram set dnspriv_enable=0
    nvram commit
    service restart_dnsmasq >/dev/null 2>&1
    printf "%s\n" "$INFO DNS Environment is Ready."
  else
    printf "%s\n" "$INFO DNS Environment is Ready."
  fi
}

check_dns_filter () {
  local DNSFIL=$(nvram get dnsfilter_enable_x)
  if [ "$1" -eq 0 ] && [ "$DNSFIL" -ne 0 ]; then
    nvram set dnsfilter_enable_x="0"
    nvram commit
    service restart_firewall >/dev/null 2>&1
    service restart_dnsmasq >/dev/null 2>&1
    printf "%s\n" "$INFO DNS will not be forced through this proxy."
    return
  fi
  if [ "$1" -eq 1 ] && [ "$DNSFIL" -ne 1 ]; then
    nvram set dnsfilter_custom1=""
    nvram set dnsfilter_custom2=""
    nvram set dnsfilter_custom3=""
    nvram set dnsfilter_enable_x="1"
    nvram set dnsfilter_mode="11"
    nvram set dnsfilter_rulelist=""
    nvram set dnsfilter_rulelist1=""
    nvram set dnsfilter_rulelist2=""
    nvram set dnsfilter_rulelist3=""
    nvram set dnsfilter_rulelist4=""
    nvram set dnsfilter_rulelist5=""
    nvram set dhcp_dns1_x=""
    nvram set dhcp_dns2_x=""
    nvram commit
    service restart_firewall >/dev/null 2>&1
    service restart_dnsmasq >/dev/null 2>&1
    printf "%s\n" "$INFO DNSFilter is set to Control DNS."
  elif [ "$1" -eq 1 ] && [ "$DNSFIL" -ne 0 ]; then
    printf "%s\n" "$INFO DNSFilter is Already on." "$INFO You can choose to keep any custom dnsfilter values and only redirect non-custom traffic or send all traffic through this proxy."
    read_yesno "Do you want to redirect only SOME DNS resolutions on your network through this proxy?" && check_dns_filter_some 0 || check_dns_filter_some 1
  fi
}

check_dns_filter_some () {
  if [ "$1" -eq 0 ]; then
    nvram set dnsfilter_mode="11"
    nvram commit
    service restart_firewall >/dev/null 2>&1
    service restart_dnsmasq >/dev/null 2>&1
    printf "%s\n" "$INFO DNSFilter is set to control DNS through this proxy, while leaving any Custom Rules and Values."
    return
  fi
  if [ "$1" -eq 1 ]; then
    nvram set dnsfilter_custom1=""
    nvram set dnsfilter_custom2=""
    nvram set dnsfilter_custom3=""
    nvram set dnsfilter_mode="11"
    nvram set dnsfilter_rulelist=""
    nvram set dnsfilter_rulelist1=""
    nvram set dnsfilter_rulelist2=""
    nvram set dnsfilter_rulelist3=""
    nvram set dnsfilter_rulelist4=""
    nvram set dnsfilter_rulelist5=""
    nvram set dhcp_dns1_x=""
    nvram set dhcp_dns2_x=""
    nvram commit
    service restart_firewall >/dev/null 2>&1
    service restart_dnsmasq >/dev/null 2>&1
    printf "%s\n" "$INFO DNS is set to redirecting All DNS resolutions through this proxy."
    return
  fi
}

check_jffs_enabled () {
  if [ "$(nvram get jffs2_format)" = "1" ]; then
    printf "%s\n" "$ERROR JFFS partition is scheduled to be reformatted." "$ERROR Please reboot to format or disable that setting and try again." "$ERROR Exiting..."
    exit 1
  fi
  local JFFS2_ENABLED=$(nvram get jffs2_enable)
  local JFFS2_SCRIPTS=$(nvram get jffs2_scripts)
  if [ "$JFFS2_ENABLED" -ne 1 ] || [ "$JFFS2_SCRIPTS" -ne 1 ]; then
    printf "%s\n" "$INFO JFFS custom scripts and configs are not enabled." "$INFO Enabling them now!"
    nvram set jffs2_enable=1
    nvram set jffs2_scripts=1
    nvram commit
  else
    printf "%s\n" "$INFO JFFS custom scripts and configs are already enabled."
  fi
}

check_anonymized_automatic () {
  if [ "$1" -eq 0 ] && [ "$(grep '^server_names = .*NextDNS-Custom.*' $TOML_FILE)" ] || [ "$(grep '^server_names = .*nextdns.*' $TOML_FILE)" ] || [ "$(grep '^server_names = .*Static.*' $TOML_FILE)" ]; then
    local AUTOMATIC
    printf "%s\n" "$INFO Servers that are potentially not compatible with relays are detected!" "$WARNING These servers might not work with relays." "$WARNING Use at your own risk."
    read_yesno "Do you still want to setup Wild-Card Relay Support?" && AUTOMATIC=true || AUTOMATIC=false
    if [ "$AUTOMATIC" = "true" ]; then
      local USE_BROKEN
      read_yesno "Do you want to skip using incompatible resolvers instead of using them directly?" && USE_BROKEN=true || USE_BROKEN=false
      toml_avars_prep skip_incompatible $USE_BROKEN
      choose_relays_automatic
    else
      printf "%s\n" "$INFO Continue without Relays Support"
      toml_avars_prep skip_incompatible false
    fi
  else
    local USE_BROKEN
    read_yesno "Do you want to skip using incompatible resolvers instead of using them directly?" && USE_BROKEN=true || USE_BROKEN=false
    toml_avars_prep skip_incompatible $USE_BROKEN
    choose_relays_automatic
  fi
}

check_anonymized_disabled () {
  toml_avar_disable routes
  toml_avars_prep skip_incompatible false
  printf "%s\n" "$INFO Continue without Relays Support"
}

check_anonymized_support () {
  if [ "$(grep '^dnscrypt_servers = .*true.*' $TOML_FILE)" ]; then   # Checking for Anonymized Relays.
    printf "%s\n" "$INFO Checking for Anonymized Dnscrypt Support." ".." "..." "...." "....." "......" "$INFO You may specify Wild-card Relay Support (server_name "*") with option 1 (this supports only DNSCrypt Servers)." "$WARNING All DNSCRYPT Server traffic will be sent through same set of chosen Relays with Wild-Card Option." "$INFO Option 2 gives you the choice to Setup Relays per Dnscrypt-Server." "$INFO Option 3 allows you to skip relay configuration or remove old relays configurations." "$WARNING Option 1 & 2 delete old relay configurations." "$WARNING Issues may occur if you are not using same servers as defined in relays." "$INFO What do you want to do:" "  1) All Servers with Wild-Card Relay Support." "  2) Pick Relays for DNSCRYPT servers (Per Server)." "  3) Skip Setting-up/Modifying Relay Support."
    read_input_num "Your choice" 1 3
    case $CHOSEN in
      1) 
        local AVARS_ARGS
        toml_avar_enable routes
        printf "%s\n" "$INFO This option allows you to setup wildcard relay support for all compatible servers."
        check_anonymized_automatic 0
        eval toml_avars_write "$AVARS_ARGS"
        ;;
      2)
        local AVARS_ARGS
        toml_avar_enable routes
        eval toml_avars_write "$AVARS_ARGS"
        local VARSARGS
        VARSARGS="sth-dnscrypt-se ams-dnscrypt-noads-nl dnswarden-dc2 af-dnswarden-dc3 opennic-eleix dnscrypt-jp-blahdns-ipv4 dnscrypt-fi-blahdns-ipv6 af-dnswarden-dc2-ipv6 geekdns-north opennic-R4SAS yandex ventricle.us freetsa.org cs-mo opennic-R4SAS-ipv6 geekdns-hk opennic-rico4514 qag.me captnemo-in ev-to cs-usdc geekdns-south cs-it arvind-io ibksturm dnscrypt-de-blahdns-ipv4 af-dnswarden-dc1-ipv6 ads-dnswarden-dc1-ipv6-ecs ads-dnswarden-dc2 cs-ro dnscrypt-fi-blahdns-ipv4 ev-va adguard-dns-family-ipv6 cs-usor dnscrypt.ca-1-ipv6 mrkaran scaleway-ams-ipv6 dnswarden-dc3-ipv6 dnswarden-dc2-ipv6 doh-fi-blahdns dnscrypt.eu-nl ads-dnswarden-dc2-ipv6 af-dnswarden-dc1-ipv6-ecs af-dnswarden-dc2-ipv6-ecs adguard-dns-family cs-de cs-uswa d0wn-is-ns2 scaleway-ams af-dnswarden-dc3-ipv6-ecs v.dnscrypt.uk-ipv4 cs-fr v.dnscrypt.uk-ipv6 opennic-luggs ads-dnswarden-dc3 ffmuc.net sea-dnscrypt-us ads-dnswarden-dc2-ecs jp.tiar.app cs-usga qualityology.com dnscrypt.nl-ns0 dnscrypt.eu-dk cs-nl2 d0wn-tz-ns1-ipv6 publicarray-au ads-dnswarden-dc3-ipv6 cs-ch jp.tiar.app-ipv6 dnsforfamily dnsforfamily-v6 dnscrypt-jp-blahdns-ipv6 ads-dnswarden-dc1 id-gmail securedns-ipv6 cs-fi af-dnswarden-dc2-ecs af-dnswarden-dc1-ecs dnswarden-dc1 oszx af-dnswarden-dc2 dnswarden-dc1-ipv6 scaleway-fr ads-dnswarden-dc2-ipv6-ecs dnscrypt.one-ipv6 opennic-luggs-ipv6 cs-ustx dnscrypt.uk-ipv4 dnscrypt.one opennic-luggs2-ipv6 ads-dnswarden-dc1-ipv6 securedns sfw.scaleway-fr adguard-dns cs-ca2 af-dnswarden-dc3-ecs ffmuc.net-v6 cs-usnc dnscrypt.uk-ipv6 dnscrypt.eu-dk-ipv6 cs-lv publicarray-au2 cs-usil adguard-dns-ipv6 dnswarden-dc3 geekdns-west soltysiak af-dnswarden-dc3-ipv6 cs-swe dnscrypt.ca-2-ipv6 ads-dnswarden-dc3-ipv6-ecs ads-dnswarden-dc3-ecs cs-ca dnscrypt-de-blahdns-ipv6 ams-dnscrypt-nl dnscrypt.ca-1 comodo-02 af-dnswarden-dc1 ads-dnswarden-dc1-ecs cs-usca opennic-luggs2 dnscrypt.ca-2 d0wn-tz-ns1 cs-nl opennic-bongobow id-gmail-ipv6 cs-pl"
        local COUNT
        local DNSCRYPT
        local SERVER
        COUNT=0
        for DNSCRYPT in $VARSARGS; do
          if [ "$(grep '^server_names = .*'${DNSCRYPT}'.*' $TOML_FILE)" ]; then
            SERVER=$(echo "$DNSCRYPT")
            printf "%s\n" "$INFO The installer detected support for Anonymized Dnscrypt" "$INFO Choose Relays for DNSCRYPT server"
            if [ $COUNT -eq 0 ]; then
              local AVARS_ARGS
              printf "%s\n" "$INFO Found $DNSCRYPT server."
              choose_relays_manual
              eval toml_avars_write "$AVARS_ARGS"
            else
              printf "%s\n" "$INFO Found $DNSCRYPT server."
              choose_relays_manual_next
            fi
            COUNT=$((COUNT + 1))
          fi
        done
        local FRAGSBLOCKED
        FRAGSBLOCKED="cisco cisco-ipv6 cisco-familyshield cisco-familyshield-ipv6 quad9-dnscrypt-ip4-filter-alt quad9-dnscrypt-ip4-filter-pri quad9-dnscrypt-ip4-nofilter-alt quad9-dnscrypt-ip4-nofilter-pri quad9-dnscrypt-ip6-filter-alt quad9-dnscrypt-ip6-filter-pri quad9-dnscrypt-ip6-nofilter-alt quad9-dnscrypt-ip6-nofilter-pri cleanbrowsing-adult cleanbrowsing-family-ipv6 cleanbrowsing-family cleanbrowsing-security"
        local BLOCKED
        local FRAG
        local NUMFRAG
        NUMFRAG=0
        for BLOCKED in $FRAGSBLOCKED; do
         if [ "$(grep '^server_names = .*'${BLOCKED}'.*' $TOML_FILE)" ]; then
            if [ "$NUMFRAG" -eq 0 ]; then
              local AVARS_ARGS=""
              local USE_BROKEN
              printf "%s\n" "$WARNING Found Incompatible Server(s)."
              read_yesno "Do you want to skip using incompatible resolvers instead of using them directly?" && USE_BROKEN=true || USE_BROKEN=false
              toml_avars_prep skip_incompatible $USE_BROKEN
              eval toml_avars_write "$AVARS_ARGS"
            fi
            NUMFRAG=$((NUMFRAG + 1))
          fi          
        done
        if [ "$COUNT" -eq 0 ] && [ "$NUMFRAG" -eq 0 ]; then
          local AVARS_ARGS
          printf "%s\n" "$WARNING No compatible servers detected." "$INFO To continue you may still select relays for Wild-Card Support."
          read_yesno "Do you still want to setup Wild-Card Relay Support?" && check_anonymized_automatic 0 || check_anonymized_disabled
          eval toml_avars_write "$AVARS_ARGS"
        fi
        ;;
      3)
        local AVARS_ARGS
        read_yesno "Do you want to remove any old relay setups (recommended)?" && check_anonymized_disabled || printf "%s\n" "$INFO You chose to continue without setting up relays or modifying relay support."
        eval toml_avars_write "$AVARS_ARGS"
        ;;
    esac
  else
    local AVARS_ARGS
    check_anonymized_disabled
    eval toml_avars_write "$AVARS_ARGS"
  fi
}

check_opendns () {
  if [ "$(grep '^server_names = .*cisco.*' $TOML_FILE)" ]; then
    if [ -f $CONF_FILE ]; then
      local OPENDNS_USER=$(awk -F'=' '/OPENDNS_USER/ {print $2}' $CONF_FILE)
      local OPENDNS_PASSWORD=$(awk -F'=' '/OPENDNS_PASSWORD/ {print $2}' $CONF_FILE)
      if [ "$OPENDNS_USER" ] && [ "$OPENDNS_PASSWORD" ]; then
        printf "%s\n" "$INFO Found OpenDNS account ${BOLD}${OPENDNS_USER}" "$INFO What do you want to do:" "  1) Use this account" "  2) Setup new account" "  3) Disable OpenDNS account authen"
        read_input_num "Your choice" 1 3
        case $CHOSEN in
          1)
            printf "%s\n" "$INFO Use previous account ${BOLD}${OPENDNS_USER}${NORM}"
            ;;
          2)
            opendns_authen 1
            ;;
          3)
            opendns_authen 0
            ;;
        esac
      else
        read_yesno "Do you want to set up OpenDNS account ip update?" && opendns_authen 1 || opendns_authen 0
      fi
    else
      read_yesno "Do you want to set up OpenDNS account ip update?" && opendns_authen 1 || opendns_authen 0
    fi
  else
    opendns_authen 0
  fi
}

check_nextdns () {
  if [ "$(grep '^server_names = .*nextdns.*' $TOML_FILE)" ]; then
    printf "%s\n" "$INFO The installer detected a NextDNS Server Selection" "$INFO If you have a NextDNS Account visit https://my.nextdns.io/login enter your setup and copy your DNS STAMP" "$INFO What do you want to do:" "  1) Setup Your SDNS STAMP" "  2) Skip dont have account"
    read_input_num "Your choice" 1 2
    case $CHOSEN in
       1)
        printf "%s\n" "$INFO You have specified to define NextDNS-Custom"
        nextdns_authen 1
        ;;
       2)
        printf "%s\n" "$INFO You have chosen to skip NextDNS-Custom"
        nextdns_authen 0
        ;;
    esac
  fi
}

check_swap () {
  local SWAP_SIZE=$(awk '/SwapTotal/ {print $2}' /proc/meminfo)
  if [ "$SWAP_SIZE" -gt 0 ]; then
    printf "%s\n" "$INFO Swap file is already setup"
    end_op_message 0
    return
  fi

  inst_swap
}

check_version () {
  if [ -f ${TARG_DIR}/installer ] && [ -f ${TARG_DIR}/dnscrypt-proxy ]; then
    local NW_STATE
    local RES_STATE
    ping 1.1.1.1 -c1 -W2 >/dev/null 2>&1
    NW_STATE=$?
    nslookup google.com >/dev/null 2>&1
    RES_STATE=$?
    if [ -z "$(pidof dnscrypt-proxy)" ] || [ $NW_STATE -eq 0 ] && [ $RES_STATE -ne 0 ]; then
      printf "%s\n" "$ERROR No Internet Detected or Dnscrypt-Proxy is Dead, Skipping Version Check." "$INFO Run Option 3 to reconfigure, before trying option 1."
      end_op_message
    else
      local RURL
      local RMNSTALL
      local LINSTALL
      local MD5SUM_L
      local MD5SUM_R
      RURL="https://raw.githubusercontent.com/thuantran/dnscrypt-asuswrt-installer/master/installer"
      LINSTALL="v$(awk '{ print }' "${TARG_DIR}/installer" | grep -m1 "^DI_VERSION=" | grep -oE '[0-9]{1,2}([.][0-9]{1,2})([.][0-9]{1,2})')"
      RMNSTALL="v$(curl -sL "$RURL" | grep -m1 "^DI_VERSION=" | grep -oE '[0-9]{1,2}([.][0-9]{1,2})([.][0-9]{1,2})')"
      MD5SUM_L="$(md5sum ${TARG_DIR}/installer | cut -d' ' -f1)"
      MD5SUM_R="$(curl -fsL "$RURL" | md5sum | awk '{print $1}')"      
      [ -z "$LINSTALL" ] && exit 1
      [ -z "$RMNSTALL" ] && exit 1      
      if [ "$RMNSTALL" != "$LINSTALL" ]; then
        printf "%s\n" "$INFO New DI_VERSION=$RMNSTALL Available!" "$INFO Run Option 1 of the Installer to upgrade DNScrypt Asuswrt Installer."
      elif [ "$MD5SUM_R" = "$MD5SUM_L" ]; then
        printf "%s\n" "$INFO DI_VERSION=$LINSTALL"
      else
        printf "%s\n" "$INFO DI_VERSION=$LINSTALL, but a New Minor Update is Available!" "$INFO Run Option 1 of the Installer to upgrade DNScrypt Asuswrt Installer."
      fi      
      local LVERSION
      LVERSION="$("${TARG_DIR}/dnscrypt-proxy" -version)"      
      [ -z "$LVERSION" ] && exit 1
      [ -z "$DNSCRYPT_VER" ] && exit 1
      if [ "$DNSCRYPT_VER" != "$LVERSION" ]; then
        printf "%s\n" "$INFO New DNSCRYPT_VER=$DNSCRYPT_VER Available!" "$INFO Run Option 1 of the Installer to upgrade DNScrypt Proxy."
      else
        printf "%s\n" "$INFO DNSCRYPT_VER=$LVERSION"
      fi
      if [ -f ${TARG_DIR}/manager ]; then
        local MD5SUM_LM
        local MURL
        local MD5SUM_M
        local L_GEN
        MD5SUM_LM="$(md5sum ${TARG_DIR}/manager | cut -d' ' -f1)"
        L_GEN="https://raw.githubusercontent.com/thuantran/dnscrypt-asuswrt-installer/master/gen"
        MURL="${L_GEN}/manager"
        MD5SUM_M="$(curl -fsL "$MURL" | md5sum | awk '{print $1}')"      
        if [ "$MD5SUM_M" = "$MD5SUM_LM" ]; then
          printf "%s\n" "$INFO Manager file is Up-To-Date!"
        else
          printf "%s\n" "$INFO New Manager file is Available!" "$INFO Run Option 1 of the Installer to upgrade the Manager File."
        fi
      fi
    fi
  fi
}

choose_dnscrypt_server () {
  local USE_IPV6
  read_yesno "Do you want to use DNS server over IPv6 (yes only if your connection has IPv6)?" && USE_IPV6=true || USE_IPV6=false
  toml_gvars_prep ipv6_servers $USE_IPV6
  printf "%s\n" "$INFO Choose DNS resolving load balancing strategy:" "  1) p2 (default)" "  2) ph" "  3) first" "  4) random"
  read_input_num "Select your mode" 1 4
  case $CHOSEN in
    1)
      toml_gvars_prep lb_strategy "\'p2\'"
      ;;
    2)
      toml_gvars_prep lb_strategy "\'ph\'"
      ;;
    3)
      toml_gvars_prep lb_strategy "\'first\'"
      ;;
    4)
      toml_gvars_prep lb_strategy "\'random\'"
      ;;
  esac
  read_yesno "Do you want to use load balance estimator to adjust resolvers based on latency calculations?" && USE_LBE=true || USE_LBE=false
  toml_gvars_prep lb_estimator $USE_LBE
  printf "%s\n" "$INFO Choose how your DNS servers are selected:" "  1) Automatically" "  2) Manually" "  3) Static"
  read_input_num "Select your mode" 1 3
  case $CHOSEN in
    1)
      choose_dnscrypt_server_auto
      read_yesno "Do you want to choose which servers to disable (this can be a long process)?" && CHOOSE_DISABLED=true || CHOOSE_DISABLED=false
      if [ "$CHOOSE_DISABLED" = "true" ]; then
        choose_dnscrypt_server_disabled
      elif [ "$CHOOSE_DISABLED" = "false" ]; then
        printf "%s\n" "$INFO Continuing without disabling any DNS servers."
        toml_gvar_disable disabled_server_names
      fi
      ;;
    2)
      toml_gvar_disable disabled_server_names
      choose_dnscrypt_server_manual
      ;;
    3)
      toml_gvar_disable disabled_server_names
      choose_dnscrypt_server_static
      ;;
  esac
}

choose_dnscrypt_server_auto () {
  toml_gvar_disable server_names
  read_yesno "Use only servers that support the DNSCrypt protocol" && toml_gvars_prep dnscrypt_servers true dnscrypt_ephemeral_keys true || toml_gvars_prep dnscrypt_servers false dnscrypt_ephemeral_keys false
  read_yesno "Use only servers that support the DNS-over-HTTPS protocol" && toml_gvars_prep doh_servers true tls_disable_session_tickets true || toml_gvars_prep doh_servers false tls_disable_session_tickets false
  read_yesno "Use only servers that support DNSSEC" && toml_gvars_prep require_dnssec true || toml_gvars_prep require_dnssec false
  read_yesno "Use only servers that do not log user's queries" && toml_gvars_prep require_nolog true || toml_gvars_prep require_nolog false
  read_yesno "Use only servers that do not filter result" && toml_gvars_prep require_nofilter true || toml_gvars_prep require_nofilter false
}

choose_dnscrypt_server_disabled () {
  local INDEX=$1
  if [ -z "$INDEX" ]; then
    [ "$USE_IPV6" = "true" ] && USE_IPV6="NOMATCH" || USE_IPV6="ipv6"
    local RESOLVERS
    printf "%s\n" "$INFO Available DNS servers to disable: "
    INDEX=$(awk -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT)' $TARG_DIR/public-resolvers.md | wc -l)
    awk -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT) {printf "  "; printf ++i") "$2": "; getline; getline; print}' $TARG_DIR/public-resolvers.md
    read_input_num "Please choose DNS server to disable" 1 "$INDEX"
  else
    read_input_num "Please choose next DNS server to disable or press n to stop" 1 "$INDEX" n
    if [ $? -eq 1 ]; then
      toml_gvars_prep disabled_server_names "\"$RESOLVERS\""
      return
    fi
  fi
  local ITEM
  ITEM=$(awk -v INDEX="$CHOSEN" -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT) {i++} i==INDEX {print $2;exit}' $TARG_DIR/public-resolvers.md)
  if [ "$(echo "$RESOLVERS" | grep -F "'$ITEM'")" ]; then
    printf "%s\n" "$INFO $ITEM is already set."
  else
    if [ "$RESOLVERS" ]; then
      RESOLVERS="${RESOLVERS%?}, '$ITEM']"
    else
      RESOLVERS="['$ITEM']"
    fi
  fi
  choose_dnscrypt_server_disabled "$INDEX"
}

choose_dnscrypt_server_manual () {
  local INDEX=$1
  if [ -z "$INDEX" ]; then
    [ "$USE_IPV6" = "true" ] && USE_IPV6="NOMATCH" || USE_IPV6="ipv6"
    local RESOLVERS
    toml_gvars_prep dnscrypt_servers true dnscrypt_ephemeral_keys true doh_servers true tls_disable_session_tickets true require_dnssec false require_nolog false require_nofilter false
    printf "%s\n" "$INFO Available DNS servers: "
    INDEX=$(awk -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT)' $TARG_DIR/public-resolvers.md | wc -l)
    awk -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT) {printf "  "; printf ++i") "$2": "; getline; getline; print}' $TARG_DIR/public-resolvers.md
    read_input_num "Please choose DNS server." 1 "$INDEX"
  else
    read_input_num "Please choose next DNS server or press n to stop." 1 "$INDEX" n
    if [ $? -eq 1 ]; then
      toml_gvars_prep server_names "\"$RESOLVERS\""
      return
    fi
  fi
  local ITEM
  ITEM=$(awk -v INDEX="$CHOSEN" -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT) {i++} i==INDEX {print $2;exit}' $TARG_DIR/public-resolvers.md)
  if [ "$(echo "$RESOLVERS" | grep -F "'$ITEM'")" ]; then
    printf "%s\n" "$INFO $ITEM is already set"
  else
    if [ "$RESOLVERS" ]; then
      RESOLVERS="${RESOLVERS%?}, '$ITEM']"
    else
      RESOLVERS="['$ITEM']"
    fi
  fi
  choose_dnscrypt_server_manual "$INDEX"
}

choose_dnscrypt_server_static () {
  printf "%s\n" "$INFO This feature allows you to define a single server or multiple servers using the sdns stamp of the server." "$INFO This assigns the server with a custom name you can specify as a static option." "$INFO This is only necessary if the Server is not available as an option on the list of servers under manual option." "$INFO If you do not want to continue down this path please select option 3 to return to server selection menu." "$INFO What do you want to do:" "  1) Setup Static Servers Only." "  2) Setup Static Servers with Addition of Manually Chosen Servers." "  3) Go back to server selection menu."
  read_input_num "Your choice" 1 3
    case $CHOSEN in
      1)
        printf "%s\n" "$INFO You have specified to define a Static Server."
        read_yesno "Do you want to remove any old static configurations?" && toml_static_removal || printf "%s\n" "$INFO Continuing to static server configuration."
        static_chosen 0
        ;;
      2)
        printf "%s\n" "$INFO You have chosen select Manually Chosen Servers First."
        read_yesno "Do you want to remove any old static configurations?" && toml_static_removal || printf "%s\n" "$INFO Continuing to static server configuration."
        static_choose_manual_addition
        ;;
      3)
        printf "%s\n" "$INFO You have chosen to go back." "$INFO Choose how your DNS servers are selected:" "  1) Automatically" "  2) Manually" "  3) Static"
        read_input_num "Select your mode" 1 3
        case $CHOSEN in
          1)
            choose_dnscrypt_server_auto
            ;;
          2)
            choose_dnscrypt_server_manual
            ;;
          3)
            choose_dnscrypt_server_static
            ;;
        esac
        ;;
    esac
}

choose_relays_automatic () {
  local INDEX=$1
  if [ -z "$INDEX" ]; then
    [ "$USE_IPV6" = "true" ] && USE_IPV6="NOMATCH" || USE_IPV6="ipv6"
    local RELAYS
    printf "%s\n" "$INFO Available Relay servers: "
    INDEX=$(awk -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT)' $TARG_DIR/relays.md | wc -l)
    awk -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT) {printf "  "; printf ++i") "$2": "; getline; getline; print}' $TARG_DIR/relays.md
    read_input_num "Please choose RELAY server" 1 "$INDEX"
  else
    read_input_num "Please choose next RELAY server or press n to stop" 1 "$INDEX" n      
    if [ $? -eq 1 ]; then
       toml_avars_prep routes "\"[ { server_name='*', via=$RELAYS } ]\""
      return
    fi
  fi
  local ITEM
  ITEM=$(awk -v INDEX="$CHOSEN" -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT) {i++} i==INDEX {print $2;exit}' $TARG_DIR/relays.md)
  if [ "$(echo "$RELAYS" | grep -F "'$ITEM'")" ]; then
    printf "%s\n" "$INFO $ITEM is already set."
  else
    if [ "$RELAYS" ]; then
      RELAYS="${RELAYS%?}, '$ITEM']"
    else
      RELAYS="['$ITEM']"
    fi
  fi
  choose_relays_automatic "$INDEX"
}

choose_relays_manual () {
  local INDEX=$1
  if [ -z "$INDEX" ]; then
    [ "$USE_IPV6" = "true" ] && USE_IPV6="NOMATCH" || USE_IPV6="ipv6"
    local RELAYS
    printf "%s\n" "$INFO Available Relay servers: "
    INDEX=$(awk -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT)' $TARG_DIR/relays.md | wc -l)
    awk -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT) {printf "  "; printf ++i") "$2": "; getline; getline; print}' $TARG_DIR/relays.md
    read_input_num "Please choose RELAY server" 1 "$INDEX"
  else
    read_input_num "Please choose next RELAY server or press n to stop" 1 "$INDEX" n      
    if [ $? -eq 1 ]; then
       toml_avars_prep routes "\"[ { server_name='$SERVER', via=$RELAYS } ]\"" 
      return
    fi
  fi
  local ITEM
  ITEM=$(awk -v INDEX="$CHOSEN" -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT) {i++} i==INDEX {print $2;exit}' $TARG_DIR/relays.md) 
  if [ "$(echo "$RELAYS" | grep -F "'$ITEM'")" ]; then
    printf "%s\n" "$INFO $ITEM is already set."
  else
    if [ "$RELAYS" ]; then
      RELAYS="${RELAYS%?}, '$ITEM']"
    else
      RELAYS="['$ITEM']"
    fi
  fi
  choose_relays_manual "$INDEX"
}

choose_relays_manual_next () {
  local INDEX=$1
  if [ -z "$INDEX" ]; then
    [ "$USE_IPV6" == "true" ] && USE_IPV6="NOMATCH" || USE_IPV6="ipv6"
    local RELAYS
    printf "%s\n" "$INFO Available Relay servers: "
    INDEX=$(awk -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT)' $TARG_DIR/relays.md | wc -l)
    awk -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT) {printf "  "; printf ++i") "$2": "; getline; getline; print}' $TARG_DIR/relays.md
    read_input_num "Please choose RELAY server" 1 "$INDEX"
  else
    read_input_num "Please choose next RELAY server or press n to stop" 1 "$INDEX" n      
    if [ $? -eq 1 ]; then
       toml_nvars_replace "} ]" "}, { server_name='$SERVER', via=$RELAYS } ]" $TOML_FILE 
      return
    fi
  fi
  local ITEM
  ITEM=$(awk -v INDEX="$CHOSEN" -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT) {i++} i==INDEX {print $2;exit}' $TARG_DIR/relays.md)
  if [ "$(echo "$RELAYS" | grep -F "'$ITEM'")" ]; then
    printf "%s\n" "$INFO $ITEM is already set."
  else
    if [ "$RELAYS" ]; then
      RELAYS="${RELAYS%?}, '$ITEM']"
    else
      RELAYS="['$ITEM']"
    fi
  fi
  choose_relays_manual_next "$INDEX"
}

cleanup () {
  rm -f $TARG_DIR/dnscrypt-fw-rules $TARG_DIR/dnscrypt-start $TARG_DIR/dnsmasq-dnscrypt-reconfig $TARG_DIR/fake-hwclock* $TARG_DIR/init-start $TARG_DIR/services-stop
}

create_dir () {
  mkdir -p "$1"
  if [ $? -ne 0 ]; then
    printf "%s\n" "$ERROR Unable to create $1!"
    return 1
  fi
}

del_between_magic () {
  local TARG=$1
  local MAGIC=$2
  [ -f "$TARG" ] || return
  local BOUNDS=$(awk -v PATT="$MAGIC" '($0 ~ PATT) {printf NR","}' "$TARG")
  if [ "$BOUNDS" ]; then
    sed -i "${BOUNDS%,}d" "$TARG"
  fi
}

del_conf () {
  [ ! -f $CONF_FILE ] && return
  local KEY
  for KEY in "$@"; do
    sed -i "/^$KEY=.*$/d" $CONF_FILE
  done
}

del_jffs_script () {
  local TARG=$1
  local LINE_NUM
  local LINE_ABOVE
  [ -f "$TARG" ] || return
  if [ "$2" ]; then
    local OP=${2:0:1}
    if [ "$OP" == "!" ]; then
      LINE_NUM=$(grep -n -F "[ -x $TARG_DIR/" "$TARG"|grep -v "$(_quote "$2")"|cut -d':' -f1)
    else
      LINE_NUM=$(grep -n -F "[ -x $TARG_DIR/" "$TARG"|grep "$(_quote "$2")"|cut -d':' -f1)
    fi
  else
    LINE_NUM=$(grep -n -F "[ -x $TARG_DIR/" "$TARG"|cut -d':' -f1)
  fi
  [ -z "$LINE_NUM" ] && return
  sed -i "${LINE_NUM}d" "$TARG"
  if [ "$LINE_NUM" -gt 1 ]; then
    LINE_NUM=$((LINE_NUM-1))
    LINE_ABOVE=$(sed "$LINE_NUMq;d" "$TARG")
    [ -z "$LINE_ABOVE" ] && sed -i "${LINE_NUM}d" "$TARG"
  fi
  [ "$(awk '{ print }' "$TARG")" = "#!/bin/sh" ] && rm -f "$TARG"
}

download_file () {
  local TARG="$1"; shift
  local PERM=$1; shift
  local URL
  local FILENAME
  local MD5SUM_OLD
  local MD5SUM_CURR
  for URL in "$@"; do
    FILENAME="$(basename "$URL")"
    MD5SUM_OLD="$([ -f "$TARG"/"$FILENAME" ] && md5sum "$TARG"/"$FILENAME" | cut -d' ' -f1)"
    MD5SUM_CURR="$(curl -fsL "$URL" | md5sum | awk '{print $1}')"
    if [ "$(printf "%s" "$MD5SUM_CURR" | wc -c)" -eq 32 ] && [ "$MD5SUM_CURR" = "$MD5SUM_OLD" ]; then
      printf "%s\n" "$INFO $FILENAME is up to date. Skipping..."
    else
      local COUNT=0
      while [ $COUNT -lt 3 ]; do
        printf "%s\n" "$INFO Downloading $FILENAME"
        curl -L -k -s "$URL" -o "$TARG"/"$FILENAME"
        if [ $? -eq 0 ]; then
          chmod "$PERM" "$TARG"/"$FILENAME"
          break
        fi
        COUNT=$((COUNT+1))
      done
      if [ $COUNT -eq 3 ]; then
        printf "%s\n" "$ERROR Unable to download ${BOLD}${URL}${NORM}"
      fi
    fi
  done
}

end_op_message () {
  [ "$1" = "0" ] && printf "%s\n" "$INFO Operation completed. You can quit or continue"
  echo =====================================================
  echo
  echo
  ScriptHeader
}

inst_dnscrypt () {
  local DNSCRYPT_TAR=dnscrypt-proxy-${DNSCRYPT_ARCH}-${DNSCRYPT_VER}.tar.gz
  local RESOLVERS_URL_PREFIX="https://download.dnscrypt.info/resolvers-list/v3/"
  local RURL
  RURL="https://raw.githubusercontent.com/thuantran/dnscrypt-asuswrt-installer/master/installer"
  local NW_STATE
  local RES_STATE
  ping 1.1.1.1 -c1 -W2 >/dev/null 2>&1
  NW_STATE=$?
  nslookup google.com >/dev/null 2>&1
  RES_STATE=$?
  if [ $NW_STATE -eq 0 ] && [ $RES_STATE -ne 0 ]; then
    printf "%s\n" "$ERROR Unable to detect the Internet!"
    end_op_message
    return
  fi
  if [ ! -d $TARG_DIR ] && [ -f $BASE_DIR/backup_dnscrypt.tar.gz ]; then
    printf "%s\n" "$INFO Backup is detected."
    local USE_OLD
    read_yesno "Do you want Restore instead?" && USE_OLD=YES || USE_OLD=NO
    if [ "$USE_OLD" = "YES" ]; then
      printf "%s\n" "$INFO Installing from an old backup!"
      backup_restore INSTALL
    elif [ "$USE_OLD" = "YES" ]; then
      printf "%s\n" "$INFO Continuing without restoring from backup!"
    fi
  elif [ -d $TARG_DIR ] && [ -f ${TARG_DIR}/dnscrypt-proxy ] && [ ! -f $BASE_DIR/backup_dnscrypt.tar.gz ]; then
    read_yesno "Do you want create a backup before updating?" && backup_restore BACKUP || printf "%s\n" "$INFO continuing without making a backup."
  fi
  create_dir $TARG_DIR
  if [ $? -ne 0 ]; then
    end_op_message
    return
  fi  
  local MD5SUM_L
  local MD5SUM_R
  [ -f ${TARG_DIR}/installer ] && MD5SUM_L="$(md5sum ${TARG_DIR}/installer | cut -d' ' -f1)" && MD5SUM_R="$(curl -fsL "$RURL" | md5sum | awk '{print $1}')"
  if [ ! -f ${TARG_DIR}/installer ]; then 
    download_file $TARG_DIR 755 $RURL
  elif [ "$MD5SUM_R" != "$MD5SUM_L" ]; then
    local NOW
    read_yesno "Do you want to update installer?" && NOW=YES || NOW=NO
    if [ "$NOW" = "YES" ]; then
      printf "%s\n" "$INFO Downloading New Installer. Re-run option 1 to get any remaining updates.."
      download_file $TARG_DIR 755 $RURL
      exec ${TARG_DIR}/installer && exit
    elif [ "$NOW" = "NO" ]; then
      printf "%s\n" "$INFO Installer update Aborted! Re-run option 1 later if you change your mind.."
    fi
  fi
  download_file $TARG_DIR 755 "$URL_GEN"/manager
  if [ -f ${TARG_DIR}/dnscrypt-proxy ]; then
    local LVERSION
    LVERSION="$("${TARG_DIR}/dnscrypt-proxy" -version)"
    [ -z "$LVERSION" ] && exit 1
    [ -z "$DNSCRYPT_VER" ] && exit 1
    if [ "$DNSCRYPT_VER" != "$LVERSION" ]; then
       printf "%s\n" "$INFO New DNSCRYPT_VER=$DNSCRYPT_VER Available!" "$INFO Updating DNSCRYPT_VER=$LVERSION to $DNSCRYPT_VER ."
       download_file $TARG_DIR 644 https://github.com/jedisct1/dnscrypt-proxy/releases/download/"${DNSCRYPT_VER}"/"${DNSCRYPT_TAR}"
       tar xzv -C $TARG_DIR -f $TARG_DIR/"$DNSCRYPT_TAR"
       if [ $? -ne 0 ]; then
          printf "%s\n" "$ERROR Unable to download dnscrypt-proxy package for your router"
          end_op_message
          return
       fi
       chown "$(nvram get http_username)":root $TARG_DIR/"$DNSCRYPT_ARCH_TAR"/*
       mv $TARG_DIR/"$DNSCRYPT_ARCH_TAR"/* $TARG_DIR
       rm -r $TARG_DIR/"$DNSCRYPT_ARCH_TAR" $TARG_DIR/"$DNSCRYPT_TAR"
       chmod 755 $TARG_DIR/dnscrypt-proxy
    else
      printf "%s\n" "$INFO DNSCRYPT_VER=$LVERSION"
    fi
  else
    download_file $TARG_DIR 644 https://github.com/jedisct1/dnscrypt-proxy/releases/download/"${DNSCRYPT_VER}"/"${DNSCRYPT_TAR}"
    tar xzv -C $TARG_DIR -f $TARG_DIR/"$DNSCRYPT_TAR"
    if [ $? -ne 0 ]; then
      printf "%s\n" "$ERROR Unable to download dnscrypt-proxy package for your router"
      end_op_message
      return
    fi
    chown "$(nvram get http_username)":root $TARG_DIR/"$DNSCRYPT_ARCH_TAR"/*
    mv $TARG_DIR/"$DNSCRYPT_ARCH_TAR"/* $TARG_DIR
    rm -r $TARG_DIR/"$DNSCRYPT_ARCH_TAR" $TARG_DIR/"$DNSCRYPT_TAR"
    chmod 755 $TARG_DIR/dnscrypt-proxy
  fi
  if [ "$("${TARG_DIR}/dnscrypt-proxy" -version)" = "2.0.44" ]; then
     download_file $TARG_DIR 644 https://raw.githubusercontent.com/DNSCrypt/dnscrypt-proxy/19c0c3f7db918ada8dd1e7b9b857099c1bb8609b/dnscrypt-proxy/example-dnscrypt-proxy.toml
  fi
  download_file $TARG_DIR 644 $RESOLVERS_URL_PREFIX/public-resolvers.md \
    $RESOLVERS_URL_PREFIX/public-resolvers.md.minisig \
    $RESOLVERS_URL_PREFIX/relays.md \
    $RESOLVERS_URL_PREFIX/relays.md.minisig
  chown nobody:nobody $TARG_DIR/public-resolvers.md $TARG_DIR/public-resolvers.md.minisig $TARG_DIR/relays.md $TARG_DIR/relays.md.minisig
  del_jffs_script /jffs/scripts/wan-start dnscrypt-start
  del_jffs_script /jffs/scripts/openvpn-event
  del_jffs_script /jffs/scripts/firewall-start
  del_jffs_script /jffs/scripts/wan-start
  write_manager_script /jffs/scripts/dnsmasq.postconf dnsmasq
  write_manager_script /jffs/scripts/init-start init-start
  setup_dnscrypt
  if [ $? -ne 0 ]; then
    end_op_message
    return
  fi
  printf "%s\n" "$INFO Starting dnscrypt-proxy..."
  $TARG_DIR/manager dnscrypt-start
  sleep 1
  if [ -z "$(pidof dnscrypt-proxy)" ]; then
    printf "%s\n" "$ERROR Couldn't start dnscrypt-proxy\n$ERROR Please send WebUI System Log to dev"
    end_op_message
    return
  fi
  service restart_dnsmasq >/dev/null 2>&1
  manager_monitor_restart

  printf "%s\n" "$INFO For dnscrypt-proxy version 2 to work reliably, you might also want to:" "$INFO  - Add swap" "$INFO  - Add a RNG" "$INFO  - Set your timezone"
  end_op_message 0
}

manager_monitor_restart () {
  local MAN_PID="$(pidof manager)"
  local PID
  if [ "$MAN_PID" ]; then
    for PID in $MAN_PID; do
      if [ "$(cat /proc/"$PID"/cmdline | grep dnscrypt)" ]; then
        kill -9 "$PID"
        break
      fi
    done
  fi
  $TARG_DIR/manager monitor-start
}

nextdns_authen () {
  local SDNS
  if [ "$1" -eq 0 ]; then
    return
  fi
  printf "%s" "$INPUT Please enter sdns$NORM: "
  read -r SDNS
  local GVARS_ARGS
  toml_gvars_prep server_names "\"['NextDNS-Custom']\""
  eval toml_gvars_write "$GVARS_ARGS"
  toml_static_removal
  toml_nvars_insert "[static]" "[static.'NextDNS-Custom']" $TOML_FILE
  toml_nvars_insert "[static.'NextDNS-Custom']" "stamp = '$SDNS'" $TOML_FILE
}
  
opendns_authen () {
  local USERNAME
  local PW1
  local PW2
  if [ "$1" -eq 0 ]; then
    del_conf OPENDNS_USER OPENDNS_PASSWORD
    return
  fi
  printf "%s" "$INPUT Please enter OpenDNS username$NORM: "
  read -r USERNAME
  printf "%s" "$INPUT Please enter OpenDNS password$NORM: "
  read -rs PW1
  echo
  printf "%s" "$INPUT Please reenter OpenDNS password$NORM: "
  read -rs PW2
  echo
  if [ -z "$PW1" ] || [ -z "$PW2" ] || [ "$PW1" != "$PW2" ]; then
    printf "%s\n" "$ERROR Password entered incorrectly!"
    opendns_authen "$1"
  fi
  write_conf OPENDNS_USER "\"$USERNAME\""
  write_conf OPENDNS_PASSWORD "\"$PW1\""
}

inst_random () {
  create_dir $TARG_DIR
  printf "%s\n" "$INFO Install a (P)RNG for better cryptographic operations" "$INFO Available random number generator providers:" "  1) HAVEGED (Preferred if you do not have a HW RNG)" "  2) RNGD (Preferred if you have a HW RNG)" "$INFO If you choose a HW RNG, please have it plugged in now before" "$INFO proceeding with your selection."
  read_input_num "Please enter the number designates your selection" 1 2
  case $CHOSEN in
    1)
      rm -f $TARG_DIR/rngd $TARG_DIR/stty
      killall -q -9 haveged
      download_file $TARG_DIR 755 "$URL_ARCH"/haveged "$URL_GEN"/manager
      write_conf RAN_PRV haveged
      $TARG_DIR/haveged -w 1024 -d 32 -i 32 -v 1
      ;;
    2)
      local RNG_DEV
      rm -f $TARG_DIR/haveged
      killall -q -9 rngd
      download_file $TARG_DIR 755 "$URL_ARCH"/rngd "$URL_ARCH"/stty "$URL_GEN"/manager
      inst_ran_dev || return
      write_conf RAN_PRV rngd
      $TARG_DIR/stty raw -echo -ixoff -F /dev/"$RNG_DEV" speed 115200
      $TARG_DIR/rngd -r /dev/"$RNG_DEV"
      ;;
  esac
  write_manager_script /jffs/scripts/init-start init-start
  end_op_message 0
}

inst_ran_dev () {
  if [ -c /dev/ttyACM0 ]; then
    local PRODSTR=$(cat /sys/class/tty/ttyACM0/device/uevent | grep ^PRODUCT\=)
    local VID=$(echo "$PRODSTR" | cut -d '=' -f 2 | cut -d '/' -f 1)
    local PID=$(echo "$PRODSTR" | cut -d '=' -f 2 | cut -d '/' -f 2)
    if [ "$VID" = "4d8" ] && [ "$PID" = "f5fe" ]; then
      printf "%s\n" "$INFO Found TrueRNG USB HW RNG"
      RNG_DEV=ttyACM0
    fi
    if [ "$VID" = "16d0" ] && [ "$PID" = "aa0" ]; then
      printf "%s\n" "$INFO Found TrueRNGpro USB HW RNG"
      RNG_DEV=ttyACM0
    fi
    if [ "$VID" = "1d50" ] && [ "$PID" = "6086" ]; then
      printf "%s\n" "$INFO Found OneRNG USB HW RNG"
      RNG_DEV=ttyACM0
    fi
    if [ "$VID" = "20df" ] && [ "$PID" = "1" ]; then
      printf "%s\n" "$INFO Found EntropyKey USB HW RNG"
      RNG_DEV=ttyACM0
    fi
  fi
  if [ -z $RNG_DEV ]; then
    printf "%s\n" "$ERROR Unable to find any HW RNG device! Retrying..."
    inst_random
    return 1
  fi
  write_conf RNG_DEV "/dev/$RNG_DEV"
}

inst_swap () {
  local SWAP_SIZE=524288
  local USB_COUNT=$(df | awk -v SWS=$(($SWAP_SIZE * 2)) '/\/tmp\/mnt\// {if ($4 > SWS){print $6}}' | wc -l)
  if [ "$USB_COUNT" -lt 1 ]; then
    printf "%s\n" "$ERROR Unable to find any external USB storage" "$ERROR Or no suitable external USB storage found" "$ERROR Please connect a USB storage with at least" "$ERROR $(($SWAP_SIZE * 2 / 1024))MB of free space."
    end_op_message
    return
  fi
  printf "%s\n" "$INFO Available partition to install swap file:$NORM"
  df | awk -v SWS=$(($SWAP_SIZE * 2)) '/\/tmp\/mnt\// {if ($4 > SWS){++i; print "  " i ") " $6 " (" $4/1024 "MB free)"}}'
  read_input_num "Please select the partition to install swap file" 1 "$USB_COUNT"
  local MOUNT=$(df | awk -v IDX="$CHOSEN" -v SWS=$(($SWAP_SIZE * 2)) '/\/tmp\/mnt\// {if ($4 > SWS){++i; if (i==IDX){print $6}}}')
  printf "%s\n" "$INFO Please wait..."
  dd if=/dev/zero of="$MOUNT/swap" bs=1024 count=$SWAP_SIZE
  local MOUNT_FS=$(df -T "$MOUNT"|awk 'FNR==2 {print $2}')
  [ "${MOUNT_FS%?}" = "ext" ] && chmod 600 "$MOUNT/swap"
  mkswap "$MOUNT/swap"
  swapon "$MOUNT/swap"
  if [ $? -ne 0 ]; then
    sed -i "/^$(_quote '[ -f $1/swap ] && swapon $1/swap')$/d" /jffs/scripts/post-mount
    sed -i "/^$(_quote '[ -f $1/swap ] && swapoff $1/swap')$/d" /jffs/scripts/unmount
    write_command_script /jffs/scripts/post-mount '[ -f "$1/swap" ] && swapon "$1/swap"'
    write_command_script /jffs/scripts/unmount '[ -f "$1/swap" ] && swapoff "$1/swap"'
    end_op_message 0
  else
    printf "%s\n" "$ERROR Unable to create swap. Get the command log to dev"
    end_op_message
  fi
}

read_input_dns () {
  printf "%s" "$INPUT $1 ${BOLD}$2: $NORM"
  read DNS_SERVER
  [ -z "$DNS_SERVER" ] && DNS_SERVER=$2
  if [ "$(printf "%s" "$DNS_SERVER" | awk -F'.' 'NF != 4 || $1 < 0 || $1 > 255 || $2 < 0 || $2 > 255 || $3 < 0 || $3 > 255 || $4 < 0 || $4 > 255 {print}')" ]; then
    printf "%s\n" "$ERROR Invalid DNS server address entered"
    read_input_dns "$@"
  fi
}

read_input_dns_n () {
  printf "%s" "$INPUT $1 ${BOLD}$2: $NORM"
  read NDNS_SERVER
  [ -z "$NDNS_SERVER" ] && NDNS_SERVER=$2
  if [ "$(printf "%s" "$NDNS_SERVER" | awk -F'.' 'NF != 4 || $1 < 0 || $1 > 255 || $2 < 0 || $2 > 255 || $3 < 0 || $3 > 255 || $4 < 0 || $4 > 255 {print}')" ]; then
    printf "%s\n" "$ERROR Invalid DNS server address entered"
    read_input_dns "$@"
  fi
}

read_input_num () {
  if [ -z "$4" ] && [ -z "$5" ] && [ -z "$6" ]; then
    printf "%s" "$INPUT $1, $BOLD[$2-$3]$NORM: "
  elif [ -n "$4" ] && [ -z "$5" ] && [ -z "$6" ]; then 
    printf "%s" "$INPUT $1, $BOLD[$2-$3/$4]$NORM: "
  elif [ -n "$4" ] && [ -n "$5" ] && [ -z "$6" ]; then 
    printf "%s" "$INPUT $1, $BOLD[$2-$3/$4/$5]$NORM: "
  elif [ -n "$4" ] && [ -n "$5" ] && [ -n "$6" ]; then 
    printf "%s" "$INPUT $1, $BOLD[$2-$3/$4/$5/$6]$NORM: "  
  fi
  read CHOSEN
  if [ "$CHOSEN" ] && [ "$CHOSEN" = "$4" ]; then
    return 1
  elif [ "$CHOSEN" ] && [ "$CHOSEN" = "$5" ]; then
    return 1
  elif [ "$CHOSEN" ] && [ "$CHOSEN" = "$6" ]; then
    return 1
  fi
  if [ -z "$(printf "%s" "$CHOSEN" | grep -E '^[0-9]+$')" ]; then
    printf "%s\n" "$ERROR Invalid character entered! Retrying..."
    read_input_num "$@"
    return
  fi
  if [ "$CHOSEN" -lt "$2" ] || [ "$CHOSEN" -gt "$3" ] ; then
    printf "%s\n" "$ERROR Chosen number is not in range! Retrying..."
    read_input_num "$@"
    return
  fi
}

read_yesno () {
  printf "%s" "$INPUT $1 $BOLD[y/n]$NORM: "
  local YESNO
  read YESNO
  case $YESNO in
    y|Y)
      return 0
      ;;
    n|N)
      return 1
      ;;
    *)
      printf "%s\n" "$ERROR Invalid input!"
      read_yesno "$@"
      ;;
  esac
}

static_chosen () {
  local SDNSSTAMP
  local STATICNAME
  if [ "$1" -eq 0 ]; then
    local STATICRESOLVER
    toml_gvars_prep dnscrypt_servers true dnscrypt_ephemeral_keys true doh_servers true tls_disable_session_tickets true require_dnssec false require_nolog false require_nofilter false
    printf "%s\n" "$INFO Please choose Static Server Name"
    printf "%s" "$INPUT Please enter staticname$NORM: "
    read -r STATICNAME
    printf "%s\n" "$INFO Please enter Static Server SDNS stamp"
    printf "%s" "$INPUT Please enter sdnsstamp$NORM: "
    read -r SDNSSTAMP
  else
    read_yesno "Do you want to set up another Static Server?" && ANOTHER=YES || ANOTHER=NO
    if [ "$ANOTHER" = "YES" ]; then
      printf "%s" "$INPUT Please enter staticname$NORM: "
      read -r STATICNAME
      printf "%s\n" "$INFO Please enter Static Server SDNS stamp"
      printf "%s" "$INPUT Please enter sdnsstamp$NORM: "
      read -r SDNSSTAMP
    elif [ "$ANOTHER" = "NO" ]; then
      printf "%s\n" "$INFO finished static setup."
      toml_gvars_prep server_names "\"$STATICRESOLVER\""
      return
    fi
  fi

  local STATIC
  STATIC="${STATICNAME}-Static"
  if [ "$(echo "$STATICRESOLVER" | grep -F "$STATIC")" ]; then
    printf "%s\n" "$INFO $STATIC is already set"
  else
    toml_nvars_insert "[static]" "[static.'${STATICNAME}-Static']" $TOML_FILE
    toml_nvars_insert "[static.'${STATICNAME}-Static']" "stamp = '$SDNSSTAMP'" $TOML_FILE
    if [ "$STATICRESOLVER" ]; then
      STATICRESOLVER="${STATICRESOLVER%?}, '$STATIC']"
    else
      STATICRESOLVER="['$STATIC']"
    fi
  fi
  static_chosen 1  
}

static_chosen_manual () {
  local SDNSSTAMP
  local STATICNAME
  if [ "$1" -eq 0 ]; then
    local STATICRESOLVER
    printf "%s\n" "$INFO Please choose Static Server Name"
    printf "%s" "$INPUT Please enter staticname$NORM: "
    read -r STATICNAME
    printf "%s\n" "$INFO Please enter Static Server SDNS stamp"
    printf "%s" "$INPUT Please enter sdnsstamp$NORM: "
    read -r SDNSSTAMP
  else
    read_yesno "Do you want to set up another Static Server?" && ANOTHER=YES || ANOTHER=NO
    if [ "$ANOTHER" = "YES" ]; then
      printf "%s" "$INPUT Please enter staticname$NORM: "
      read -r STATICNAME
      printf "%s\n" "$INFO Please enter Static Server SDNS stamp"
      printf "%s" "$INPUT Please enter sdnsstamp$NORM: "
      read -r SDNSSTAMP
    elif [ "$ANOTHER" = "NO" ]; then
      printf "%s\n" "$INFO You have finished static setup."
      toml_gvars_prep server_names "\"[${STATICRESOLVER}, $RESOLVERS]\""
      return
    fi
  fi

  local STATIC
  STATIC="${STATICNAME}-Static"
  if [ "$(echo "$STATICRESOLVER" | grep -F "$STATIC")" ]; then
    printf "%s\n" "$INFO $STATIC is already set."
  else
    toml_nvars_insert "[static]" "[static.'${STATICNAME}-Static']" $TOML_FILE
    toml_nvars_insert "[static.'${STATICNAME}-Static']" "stamp = '$SDNSSTAMP'" $TOML_FILE
    if [ "$STATICRESOLVER" ]; then
      STATICRESOLVER="${STATICRESOLVER%?}', '$STATIC'"
    else
      STATICRESOLVER="'$STATIC'"
    fi
  fi
  static_chosen_manual 1
}

static_choose_manual_addition () {
  local INDEX=$1
  if [ -z "$INDEX" ]; then
    [ "$USE_IPV6" == "true" ] && USE_IPV6="NOMATCH" || USE_IPV6="ipv6"
    local RESOLVERS
    toml_gvars_prep dnscrypt_servers true dnscrypt_ephemeral_keys true doh_servers true tls_disable_session_tickets true require_dnssec false require_nolog false require_nofilter false
    printf "%s\n" "$INFO Available DNS servers: "
    INDEX=$(awk -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT)' $TARG_DIR/public-resolvers.md | wc -l)
    awk -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT) {printf "  "; printf ++i") "$2": "; getline; getline; print}' $TARG_DIR/public-resolvers.md
    read_input_num "Please choose DNS server" 1 "$INDEX"
  else
    read_input_num "Please choose next DNS server or press n to stop" 1 "$INDEX" n
    if [ $? -eq 1 ]; then
      static_chosen_manual 0
      return
    fi
  fi
  local ITEM
  ITEM=$(awk -v INDEX="$CHOSEN" -v PATT="$USE_IPV6" '/^## / && ($0 !~ PATT) {i++} i==INDEX {print $2;exit}' $TARG_DIR/public-resolvers.md)
  if [ "$(echo "$RESOLVERS" | grep -F "'$ITEM'")" ]; then
    printf "%s\n" "$INFO $ITEM is already set"
  else
    if [ "$RESOLVERS" ]; then
      RESOLVERS="${RESOLVERS%?}', '$ITEM'"
    else
      RESOLVERS="'$ITEM'"
    fi
  fi
  static_choose_manual_addition "$INDEX"
}

setup_dnscrypt () {
  if [ ! -f $TOML_ORI ] || [ ! -f $TARG_DIR/dnscrypt-proxy ]; then
    printf "%s\n" "$ERROR dnscrypt-proxy is not installed. Aborting..."
    return
  fi
  printf "%s\n" "$INFO Configuring dnscrypt-proxy..."
  setup_dnscrypt_impl "$@"
  local RET=$?
  check_opendns
  if [ "$1" = "reconfig" ]; then
    if [ $RET -eq 0 ]; then
      printf "%s\n" "$INFO Restarting dnscrypt-proxy with new config..."
      $TARG_DIR/manager dnscrypt-start
      end_op_message 0
    else
      end_op_message 0
    fi
  fi
}

setup_dnscrypt_impl () {
  if [ -z "$1" ] && [ -f $TOML_FILE ]; then
    check_dnscrypt_toml
    if [ $? -ne 0 ]; then
      setup_dnscrypt_impl x
      return
    fi
    printf "%s\n" "$INFO Found previous dnscrypt-proxy config file"
    read_yesno "Do you want to use this file without reconfiguring?" && printf "%s\n" "$INFO Use previous settings file" || setup_dnscrypt_impl x
  else
    if [ -f $TOML_FILE ]; then
      if [ "$1" = "reconfig" ]; then
        check_dnscrypt_toml
        if [ $? -ne 0 ]; then
          setup_dnscrypt_impl x
          return
        fi
        printf "%s\n" "$INFO Found previous dnscrypt-proxy config file"
      fi
      printf "%s\n" "$INFO How do you want to reconfigure:" "$INFO   1) Start from previous settings file" "$INFO   2) Start from default config"
      read_input_num "Your selection" 1 2
      case $CHOSEN in
        1)
          printf "%s\n" "$INFO Use previous settings file"
          ;;
        2)
          printf "%s\n" "$INFO Backing up previous settings file..."
          mv $TOML_FILE $TOML_BAK
          cp -f $TOML_ORI $TOML_FILE
          ;;
      esac
    else
      cp -f $TOML_ORI $TOML_FILE
    fi
    local GVARS_ARGS
    read_yesno "Do you want to redirect all DNS resolutions on your network through this proxy?" && check_dns_filter 1 || check_dns_filter 0
    toml_gvar_enable dnscrypt_ephemeral_keys
    toml_gvar_enable tls_disable_session_tickets
    choose_dnscrypt_server
    printf "%s\n" "$INFO Set the DNS server(s) for initializing dnscrypt-proxy" "$INFO and router services (e.g. ntp) at boot"
    read_input_dns "Default is" 9.9.9.9
    read_input_dns_n "2nd Default is" 8.8.8.8
    read_input_num "Set log level, default is 2, 0 is the most verbose" 0 6
    toml_nvars_replace "fallback_resolver =" "fallback_resolvers = ['$DNS_SERVER:53', '$NDNS_SERVER:53']" $TOML_FILE
    toml_gvars_prep fallback_resolvers "\"['$DNS_SERVER:53', '$NDNS_SERVER:53']\"" log_level "$CHOSEN" ignore_system_dns true listen_addresses "[\'127.0.1.1:53\']" cache false cert_ignore_timestamp true user_name "\'nobody\'" max_clients 25000 keepalive 120 netprobe_timeout 120 netprobe_address "\'$DNS_SERVER:53\'"
    printf "%s\n" "$INFO Writing dnscrypt-proxy configuration..."
    eval toml_gvars_write "$GVARS_ARGS"
    printf "%s\n" "$INFO Evaluating other possibilities for dnscrypt-proxy configuration..."
    check_nextdns
    check_anonymized_support
    check_dnscrypt_toml
    if [ $? -ne 0 ]; then
      printf "%s\n" "$INFO Writing dnscrypt-proxy configuration failed " "$INFO Please send $TOML_ERR file and screen log of " "$INFO all operations you have made to this script dev"
      return 1
    fi
  fi
}

set_timezone () {
  local TMP=/root
  local TZ_DATA=tzdata-2018c-1-any.pkg.tar.bz2
  download_file $TARG_DIR 755 "$URL_GEN"/manager
  download_file $TMP 644 "$URL_GEN"/$TZ_DATA
  local INDEX=$(tar tjf $TMP/$TZ_DATA | awk -F'/' '!/\/$/ && !/PaxHeader/ && /\/posix\//' | wc -l)
  printf "%s\n" "$INFO Available timezones/locations:"
  tar tjf $TMP/$TZ_DATA | awk -F'/' '!/\/$/ && !/PaxHeader/ && /\/posix\//' | sort | awk -v INDEX=0 -F'/' '!/\/$/ {++INDEX;printf "  " INDEX") ";for (i=5; i<NF; i++)  printf $i "/"; print $NF}'
  read_input_num "Select your timezone/location" 1 "$INDEX"
  local TZ_FILE="$(tar tjf $TMP/$TZ_DATA | awk -F'/' '!/\/$/ && !/PaxHeader/ && /\/posix\//' | sort | awk -v INDEX="$CHOSEN" '{++i}i==INDEX{print $0}')"
  printf "%s\n" "$INFO $(basename "$TZ_FILE") selected"
  tar xjf $TMP/$TZ_DATA -C $TMP usr/share/zoneinfo/posix
  mv "$TMP/$TZ_FILE" $TARG_DIR/localtime
  if [ $? -ne 0 ]; then
    printf "%s\n" "$ERROR Unable to set your timezone file"
    end_op_message
    return
  fi

  write_manager_script /jffs/scripts/init-start init-start
  write_manager_script /jffs/scripts/services-stop services-stop
  ln -sf $TARG_DIR/localtime /etc/localtime
  [ "$(pidof dnscrypt-proxy)" ] && $TARG_DIR/manager dnscrypt-start
  rm -r $TMP/$TZ_DATA $TMP/usr
  end_op_message 0
}

toml_avar_disable () {
  local VAR=$1
  local IDX_NX_AVAR=$(awk 'END {print NR}' $TOML_FILE)
  sed -i "1,$IDX_NX_AVAR{s/\(^$VAR = .*\)/# \1/}" $TOML_FILE
}

toml_avar_enable () {
  local VAR=$1
  local IDX_NX_AVAR=$(awk 'END {print NR}' $TOML_FILE)
  sed -i "1,$IDX_NX_AVAR{/^#.*$VAR = .*$/s/^#\ //}" $TOML_FILE
}

toml_avars_prep () {
  AVARS_ARGS="$AVARS_ARGS $@"
}

toml_avars_write () {
  local IDX_NX_AVAR=$(awk 'END {print NR}' $TOML_FILE)
  local IDX_GLB_INS=$(awk -v VAR="#.*Anonymized DNS        #*" '($0 ~ VAR) {while (getline) {if ($0 ~ "^$") break} print NR;exit}' $TOML_FILE)
  local VAR
  local VALUE
  local TO
  local INDEX
  local HAS_GLB_INS
  local SED_CMD
  while [ $# -gt 0 ]; do
    VAR=$1; shift
    VALUE=$1; shift
    TO=$(_quote "$VAR = $VALUE")
    INDEX=$(awk -v IDX="$IDX_NX_AVAR" -v VAR="^$VAR = " '($0 ~ VAR) && (NR < IDX) {print NR; exit}' $TOML_FILE)
    if [ "$INDEX" ]; then
      SED_CMD="${INDEX}{s/.*/${TO}/};${SED_CMD}"
      continue
    fi
    INDEX=$(awk -v IDX="$IDX_NX_AVAR" -v VAR="#.*$VAR = " '($0 ~ VAR) && (NR < IDX) {print NR; exit}' $TOML_FILE)
    if [ "$INDEX" ]; then
      SED_CMD="${INDEX}{s/.*/${TO}/};${SED_CMD}"
      continue
    fi
    [ -z "$HAS_GLB_INS" ] && SED_CMD="${SED_CMD}${IDX_GLB_INS}{s/^/\n${TO}\n" || SED_CMD="${SED_CMD}${TO}\n"
    HAS_GLB_INS=1
  done
  [ "$HAS_GLB_INS" ] && SED_CMD="${SED_CMD}/}"
  sed -i "${SED_CMD%;}" $TOML_FILE
}

toml_gvar_disable () {
  local VAR=$1
  local IDX_NX_GVAR=$(awk '/^\[.*\]$/ {print NR;exit}' $TOML_FILE)
  sed -i "1,$IDX_NX_GVAR{s/\(^$VAR = .*\)/# \1/}" $TOML_FILE
}

toml_gvar_enable () {
  local VAR=$1
  local IDX_NX_GVAR=$(awk '/^\[.*\]$/ {print NR;exit}' $TOML_FILE)
  sed -i "1,$IDX_NX_GVAR{/^#.*$VAR = .*$/s/^#\ //}" $TOML_FILE
}

toml_gvars_prep () {
  GVARS_ARGS="$GVARS_ARGS $@"
}

toml_gvars_write () {
  local IDX_NX_GVAR=$(awk '/\[.+\]/ && !/(#| = )/ {print NR;exit}' $TOML_FILE)
  local IDX_GLB_INS=$(awk -v VAR="#.*Global settings.*" '($0 ~ VAR) {while (getline) {if ($0 ~ "^$") break} print NR;exit}' $TOML_FILE)
  local VAR
  local VALUE
  local TO
  local INDEX
  local HAS_GLB_INS
  local SED_CMD
  while [ $# -gt 0 ]; do
    VAR=$1; shift
    VALUE=$1; shift
    TO=$(_quote "$VAR = $VALUE")
    INDEX=$(awk -v IDX="$IDX_NX_GVAR" -v VAR="^$VAR = " '($0 ~ VAR) && (NR < IDX) {print NR; exit}' $TOML_FILE)
    if [ "$INDEX" ]; then
      SED_CMD="${INDEX}{s/.*/${TO}/};${SED_CMD}"
      continue
    fi
    INDEX=$(awk -v IDX="$IDX_NX_GVAR" -v VAR="#.*$VAR = " '($0 ~ VAR) && (NR < IDX) {print NR; exit}' $TOML_FILE)
    if [ "$INDEX" ]; then
      SED_CMD="${INDEX}{s/.*/${TO}/};${SED_CMD}"
      continue
    fi
    [ -z $HAS_GLB_INS ] && SED_CMD="${SED_CMD}${IDX_GLB_INS}{s/^/\n${TO}\n" || SED_CMD="${SED_CMD}${TO}\n"
    HAS_GLB_INS=1
  done
  [ "$HAS_GLB_INS" ] && SED_CMD="${SED_CMD}/}"
  sed -i "${SED_CMD%;}" $TOML_FILE
}

toml_nvars_insert () {
  PATTERN=$(_quote "$1")
  CONTENT=$(_quote "$2")
  sed -i "/$PATTERN/a$CONTENT" "$3"
}

toml_nvars_replace () {
  PATTERN=$(_quote "$1")
  CONTENT=$(_quote "$2")
  sed -i "s/$PATTERN/$CONTENT/" "$3"
}

toml_nvars_append () {
  echo "$1" >> "$2"
}

toml_nvars_delete () {
  PATTERN=$(_quote "$1")
  sed -i "/$PATTERN/d" "$2"
}

toml_static_removal () {
printf "%s\n" "$INFO Removing any static server configuration."
toml_nvars_delete "[static.'" $TOML_FILE
toml_nvars_delete "stamp =" $TOML_FILE
}

uninst_all () {
  if [ -f $BASE_DIR/backup_dnscrypt.tar.gz ]; then
    printf "%s\n" "$INFO Old Backup Detected!"
    read_yesno "Do you want to remove backup?(this will prevent resorting later)" && rm -rf $BASE_DIR/backup_dnscrypt.tar.gz || printf "%s\n" "$INFO Keeping backup instead."
  fi
  rm -rf $TARG_DIR
  del_jffs_script /jffs/scripts/dnsmasq.postconf
  del_jffs_script /jffs/scripts/init-start
  del_jffs_script /jffs/scripts/firewall-start
  del_jffs_script /jffs/scripts/services-stop
  del_jffs_script /jffs/scripts/wan-start
  service restart_dnsmasq >/dev/null 2>&1
  killall -q -9 haveged rngd dnscrypt-proxy
  local MAN_PID="$(pidof manager)"
  local PID
  if [ "$MAN_PID" ]; then
    for PID in $MAN_PID; do
      if [ "$(awk '{ print }' /proc/"$PID"/cmdline | grep dnscrypt)" ]; then
        kill -9 "$PID"
        break
      fi
    done
  fi
  end_op_message 0
}

uninst_dnscrypt () {
  printf "%s\n" "$INFO Uninstalling dnscrypt-proxy..."
  rm -f $TARG_DIR/dnscrypt-proxy $TARG_DIR/nonroot
  del_jffs_script /jffs/scripts/dnsmasq.postconf
  del_jffs_script /jffs/scripts/firewall-start
  del_jffs_script /jffs/scripts/wan-start
  killall -q dnscrypt-proxy
  service restart_dnsmasq >/dev/null 2>&1
  printf "%s\n" -e "$INFO Some configuration files are not removed in case you want to reinstall"
  end_op_message 0
}

uninst_random () {
  printf "%s\n" "$INFO Uninstalling (P)RNG..."
  rm -f $TARG_DIR/haveged $TARG_DIR/rngd $TARG_DIR/stty
  killall -q -9 haveged rngd
  del_conf RAN_PRV RNG_DEV
  [ ! -f $TARG_DIR/localtime ] && [ ! -f $TARG_DIR/dnscrypt-proxy ] && del_jffs_script /jffs/scripts/init-start; del_jffs_script /jffs/scripts/services-stop
  end_op_message 0
}

unset_timezone () {
  rm -f $TARG_DIR/localtime
  [ -z "$(grep \"^RAN_PRV=.*$\" $TARG_DIR/.config)" ] && [ ! -f $TARG_DIR/dnscrypt-proxy ] && del_jffs_script /jffs/scripts/init-start; del_jffs_script /jffs/scripts/services-stop
  end_op_message 0
}

write_conf () {
  local VAR=$1
  local VALUE="$2"
  [ -f $TARG_DIR/.opendns-auth ] && mv $TARG_DIR/.opendns-auth $CONF_FILE && chmod 644 $CONF_FILE
  if [ ! -f $CONF_FILE ]; then
    touch $CONF_FILE && chmod 644 $CONF_FILE
  fi
  if [ "$(grep "$VAR" $CONF_FILE)" ]; then
    VALUE=$(_quote "$VALUE")
    sed -i "/^$VAR=/s/=.*/=$VALUE/" $CONF_FILE
  else
    echo "$VAR=$VALUE" >> $CONF_FILE
  fi
}

write_command_script () {
  local TARG=$1
  local COMMAND=$2
  local FILENAME="$(basename "$TARG")"
  if [ ! -f "$TARG" ]; then
    printf "%s\n" "$INFO Creating $FILENAME file"
    echo "#!/bin/sh" > "$TARG"
  fi
  chmod 755 "$TARG"
  if [ "$(grep -c -F "$COMMAND" "$TARG")" -gt 0 ]; then
    printf "%s\n" "$INFO $FILENAME file already configured"
  else
    printf "%s\n" "$INFO Configure $FILENAME file"
    echo "$COMMAND" >> "$TARG"
  fi
}

write_manager_script () {
  local TARG=$1
  local OP=$2
  local FILENAME="$(basename "$TARG")"
  local COMMAND=$TARG_DIR/manager
  if [ ! -f "$TARG" ]; then
    printf "%s\n" "$INFO Creating $FILENAME file"
    echo "#!/bin/sh" > "$TARG"
  fi
  chmod 755 "$TARG" $COMMAND
  del_between_magic "$TARG" dnscrypt-asuswrt-installer
  if [ "$(grep -c -F "[ -x $COMMAND ] && $COMMAND $OP" "$TARG")" -gt 0 ]; then
    printf "%s\n" "$INFO $FILENAME file already configured"
  else
    printf "%s\n" "$INFO Configure $FILENAME file"
    if [ "$(grep \"^$COMMAND\" "$TARG")" ]; then
      sed -i "s~^$COMMAND~[ -x $COMMAND ] \&\& $COMMAND $OP~" "$TARG"
    else
      del_jffs_script "$TARG" !manager
      [ "$(tail -1 "$TARG"|grep -c '^$')" -eq 0 ] && echo "" >> "$TARG"
      echo "[ -x $COMMAND ] && $COMMAND $OP" >> "$TARG"
    fi
  fi
}

[ "$1" ] && BRANCH=$1 || BRANCH=master
URL_GEN=https://raw.githubusercontent.com/thuantran/dnscrypt-asuswrt-installer/$BRANCH/gen
URL_ARCH=https://github.com/thuantran/dnscrypt-asuswrt-installer/raw/$BRANCH

case $(uname -m) in
  armv7l)
    URL_ARCH=$URL_ARCH/armv7
    DNSCRYPT_ARCH=linux_arm
    DNSCRYPT_ARCH_TAR=linux-arm
    printf "%s\n" "$INFO Detected ARMv7 architecture."
    ;;
  aarch64)
    URL_ARCH=$URL_ARCH/armv8
    DNSCRYPT_ARCH=linux_arm64
    DNSCRYPT_ARCH_TAR=linux-arm64
    printf "%s\n" "$INFO Detected ARMv8 architecture."
    ;;
  # mips)
    # URL_ARCH=$URL_ARCH/mips
    # DNSCRYPT_ARCH=linux_mipsle
    # DNSCRYPT_ARCH_TAR=linux-mipsle
    # printf "%s\n" "$INFO Detected MIPSEL architecture."
    # printf "%s\n" "$WARNING FOR TESTING ONLY, MIGHT NOT WORK AT ALL"
    # printf "%s\n" "$WARNING USE AT YOUR OWN RISK"
    # ;;
  *)
    printf "%s\n" "$ERROR This is unsupported platform, sorry."
    exit 1
    ;;
esac

menu () {
   printf "%s\n" "$INFO Choose what you want to do:" "  1) Install/Update dnscrypt-proxy" "  2) Uninstall dnscrypt-proxy" "  3) Configure dnscrypt-proxy" "  4) Set timezone" "  5) Unset timezone" "  6) Install (P)RNG" "  7) Uninstall (P)RNG" "  8) Install swap file" "  9) Uninstall ALL"
  [ -d $TARG_DIR ] && [ -f ${TARG_DIR}/dnscrypt-proxy ] && printf "%s\n" "  b) Backup"
  [ -d $TARG_DIR ] && [ -f ${TARG_DIR}/dnscrypt-proxy ] && [ -f $BASE_DIR/backup_dnscrypt.tar.gz ] && printf "%s\n" "  r) Restore"
  printf "%s\n" "  q) Quit"
  [ ! -d $TARG_DIR ] || [ ! -f ${TARG_DIR}/dnscrypt-proxy ] && read_input_num "Please enter the number that designates your selection:" 1 9 q
  [ -d $TARG_DIR ] && [ -f ${TARG_DIR}/dnscrypt-proxy ] && [ ! -f $BASE_DIR/backup_dnscrypt.tar.gz ] && read_input_num "Please enter the number that designates your selection:" 1 9 b q
  [ -d $TARG_DIR ] && [ -f ${TARG_DIR}/dnscrypt-proxy ] && [ -f $BASE_DIR/backup_dnscrypt.tar.gz ] && read_input_num "Please enter the number that designates your selection:" 1 9 b r q
  case $CHOSEN in
    1)
      printf "%s\n" "$INFO This operation will install dnscrypt-proxy and related files (<6MB)" "$INFO to jffs, no other data will be changed." "$INFO Also some start scripts will be installed/modified as required." ""
      read_yesno "Do you want to install dnscrypt-proxy to /jffs?" && inst_dnscrypt || ScriptHeader
      ;;
    2)
      printf "%s\n" "$INFO This operation will uninstall dnscrypt-proxy and related files" "$INFO from jffs, no other data will be changed." "$INFO Also some start scripts will be modified as required." ""
      read_yesno "Do you want to uninstall dnscrypt-proxy from /jffs?" && uninst_dnscrypt || ScriptHeader
      ;;
    3)
      printf "%s\n" "$INFO This operation allows you to configure dnscrypt-proxy" ""
      read_yesno "Do you want to proceed?" && setup_dnscrypt reconfig || ScriptHeader
      ;;
    4)
      printf "%s\n" "$INFO This operation allows you to set your router" "$INFO timezone for background services and processes" ""
      read_yesno "Do you want to proceed?" && set_timezone || ScriptHeader
      ;;
    5)
      printf "%s\n" "$INFO This operation allows you to unset your router" "$INFO timezone for background services and processes" ""
      read_yesno "Do you want to proceed?" && unset_timezone || ScriptHeader
      ;;
    6)
      printf "%s\n" "$INFO This operation will install a (P)RNG (<0.5MB)" "$INFO to jffs, no other data will be changed." "$INFO Also some start scripts will be installed/modified as required." ""
      read_yesno "Do you want to install (P)RNG to /jffs?" && inst_random || ScriptHeader
      ;;
    7)
      printf "%s\n" "$INFO This operation will uninstall (P)RNG" "$INFO from jffs, no other data will be changed." "$INFO Also some start scripts will be installed/modified as required." ""
      read_yesno "Do you want to uninstall (P)RNG from /jffs?" && uninst_random || ScriptHeader
      ;;
    8)
      printf "%s\n" "$INFO This operation will install a swap file for your device" "$INFO You need an external USB storage to host this file" ""
      read_yesno "Do you want to install a swap file (512MB on ext filesystem partition)?" && check_swap || ScriptHeader
      ;;
    9)
      printf "%s\n" "$INFO This operation will cleanup everything installed by this script (except swap)" ""
      read_yesno "Do you want to continue?" && uninst_all || ScriptHeader
      ;;
    b|B)
      printf "%s\n" "$INFO This operation will allow you to backup everything!" ""
      read_yesno "Do you want to continue?" && backup_restore BACKUP || ScriptHeader
      ;;
    r|R)
      printf "%s\n" "$INFO This operation will allow you to restore everything!" ""
      read_yesno "Do you want to continue?" && backup_restore RESTORE || ScriptHeader
      ;;
    q|Q)
      printf "%s\n" "$INFO Operations have been applied if any has been made" "$INFO In case of anomaly, please reboot your router!"
      clear
      ;;
  esac
}

ScriptHeader STARTUP
